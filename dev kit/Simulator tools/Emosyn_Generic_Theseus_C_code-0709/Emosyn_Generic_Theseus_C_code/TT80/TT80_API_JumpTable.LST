AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     1


MACRO ASSEMBLER AX51 V3.01a
OBJECT MODULE PLACED IN TT80_API_JumpTable.OBJ
ASSEMBLER INVOKED BY: C:\Keil\C51\BIN\AX51.EXE TT80_API_JumpTable.a51 SET(SMALL) DEBUG EP

LOC    OBJ             LINE     SOURCE

                          1     
                          2     
                          3     
                          4     
                          5     
                          6     
                          7     
                          8     
                          9     
                         10     
                         11     
                         12     
                         13     
                         14     
                         15     
                         16     
                         17     
                         18     
                         19     
                         20     
                         21     ;#include "../Common_Titanium/Theseus_Titanium_Family.h"
                    +1   22     
                    +1   23     
                    +1   24     
                    +1   25     
                    +1   26     
                    +1   27     
                    +1   28     
                    +1   29     
                    +1   30     
                    +1   31     
                    +1   32     
                    +1   33     
                    +1   34     
                    +1   35     
                    +1   36     
                    +1   37     
                    +1   38     
                    +1   39     
                    +1   40     
                    +1   41     
                    +1   42     
                    +1   43     
                    +1   44     
                    +1   45     
                    +1   46     
                    +1   47     
                    +1   48     
                    +1   49     
                    +1   50     
                    +1   51     
                    +1   52     
                    +1   53     
                    +1   54     
  0080              +1   55     sfr NVFSMCON       = 0x80;
  0081              +1   56     sfr SP             = 0x81;
  0082              +1   57     sfr DPL            = 0x82;
  0083              +1   58     sfr DPH            = 0x83;
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     2

  0082              +1   59     sfr DPL0           = 0x82;
  0083              +1   60     sfr DPH0           = 0x83;
  0084              +1   61     sfr DPL1           = 0x84;
  0085              +1   62     sfr DPH1           = 0x85;
  0086              +1   63     sfr DPS            = 0x86;
  0087              +1   64     sfr PCON           = 0x87;
  0088              +1   65     sfr TCON           = 0x88;
  0089              +1   66     sfr TMOD           = 0x89;
  008A              +1   67     sfr TL0            = 0x8A;
  008B              +1   68     sfr TL1            = 0x8B;
  008C              +1   69     sfr TH0            = 0x8C;
  008D              +1   70     sfr TH1            = 0x8D;
                    +1   71     
                    +1   72     
                    +1   73     
                    +1   74     
  0093              +1   75     sfr DPX            = 0x93;
  0093              +1   76     sfr DPX0           = 0x93;
  0095              +1   77     sfr DPX1           = 0x95;
                    +1   78     
                    +1   79     
                    +1   80     
                    +1   81     
  0098              +1   82     sfr SCON           = 0x98;
  0099              +1   83     sfr SBUF           = 0x99;
                    +1   84     
  00A1              +1   85     sfr CBSL           = 0xA1;
  00A2              +1   86     sfr MPTR           = 0xA2;
  00A8              +1   87     sfr IE             = 0xA8;
                    +1   88     
  00B0              +1   89     sfr SECURITYSTATUS = 0xB0;
  00B2              +1   90     sfr ISOCON         = 0xB2;
  00B4              +1   91     sfr ISOTMR         = 0xB4;
  00B8              +1   92     sfr IP             = 0xB8;
                    +1   93     
  00C0              +1   94     sfr PROGIO         = 0xC0;
                    +1   95     
  00C9              +1   96     sfr NvFsmMode      = 0xC9;
                    +1   97     
  00D0              +1   98     sfr PSW            = 0xD0;
  00D8              +1   99     sfr SPSW           = 0xD8;
                    +1  100     
  00E0              +1  101     sfr ACC            = 0xE0;
  00E8              +1  102     sfr EPSW           = 0xE8;
                    +1  103     
  00EA              +1  104     sfr MPTRX          = 0xEA;
                    +1  105     
  00F0              +1  106     sfr B              = 0xF0;
                    +1  107     
                    +1  108     
                    +1  109     
                    +1  110     
  00F7              +1  111     sfr MFCON          = 0xF7;
                    +1  112     
                    +1  113     
                    +1  114     
                    +1  115     
                    +1  116     
                    +1  117     
                    +1  118     
                    +1  119     
                    +1  120     
                    +1  121     
00D0.7              +1  122     sbit CY            = PSW^7;
00D0.6              +1  123     sbit AC            = PSW^6;
00D0.5              +1  124     sbit F0            = PSW^5;
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     3

00D0.4              +1  125     sbit RS1           = PSW^4;
00D0.3              +1  126     sbit RS0           = PSW^3;
00D0.2              +1  127     sbit OV            = PSW^2;
                    +1  128     
00D0.0              +1  129     sbit P             = PSW^0; 
                    +1  130     
                    +1  131     
                    +1  132     
                    +1  133     
0098.1              +1  134     sbit TI            = SCON^1;
0098.0              +1  135     sbit RI            = SCON^0;
                    +1  136     
                    +1  137     
                    +1  138     
                    +1  139     
0088.7              +1  140     sbit TF1           = TCON^7;
0088.6              +1  141     sbit TR1           = TCON^6;
0088.5              +1  142     sbit TF0           = TCON^5;
0088.4              +1  143     sbit TR0           = TCON^4;
0088.3              +1  144     sbit MFLT          = TCON^3;
0088.1              +1  145     sbit SINT          = TCON^1;
0088.1              +1  146     sbit USINT         = TCON^1;
0088.0              +1  147     sbit SSINT         = TCON^0;
                    +1  148     
                    +1  149     
                    +1  150     
                    +1  151     
00E8.0              +1  152     sbit AM            = EPSW^0;
00E8.1              +1  153     sbit F1            = EPSW^1;
                    +1  154     
                    +1  155     
                    +1  156     
                    +1  157     
                    +1  158     
0080.0              +1  159     sbit FSM_FINISH    = NVFSMCON^0;
0080.1              +1  160     sbit FSM_START     = NVFSMCON^1;
0080.5              +1  161     sbit FSM_RESULT    = NVFSMCON^5;
                    +1  162     
                    +1  163     
                    +1  164     
                    +1  165     
00C0.0              +1  166     sbit PULLUP_RES_STATE = PROGIO^0;
                    +1  167     
                    +1  168     
                    +1  169     
                    +1  170     
                    +1  171     
                    +1  172     
                    +1  173     
                    +1  174     
                    +1  175     
                        176     
                        177     
                        178     
                        179     ; Define EMULATOR as 1 to create code compatible with the emulator.
                        180     ; This will replace (some) NVFSM and IE usage with equivalent firmware calls.
                        181     ; ALSO change Firmware_API_JumpTable.h to match.
                        182     ; FW version 0x21 or higher is required.
                        183     ;
                        184     $set  (EMULATOR = 0)
                        185     
                        186     
                        187     ; Library Functions
                        188     
                        189     
                        190     ; FSM interface
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     4

                        191     Public Firmware_MassEraseUCM, _Firmware_MassEraseUCM
                        192     Public Firmware_ErasePageUCM, _Firmware_ErasePageUCM
                        193     Public Firmware_EraseUCM256Bytes, _Firmware_EraseUCM256Bytes
                        194     Public Firmware_EraseUCM512Bytes, _Firmware_EraseUCM512Bytes
                        195     Public Firmware_WriteByteUCM, _Firmware_WriteByteUCM
                        196     
                        197     Public Firmware_EraseUCM256Bytes_In_CODE_Space, _Firmware_EraseUCM256Bytes_In_CODE_Space
                        198     Public Firmware_EraseUCM512Bytes_In_CODE_Space, _Firmware_EraseUCM512Bytes_In_CODE_Space
                        199     Public Firmware_WriteByteUCM_In_CODE_Space, _Firmware_WriteByteUCM_In_CODE_Space
                        200     
                        201     
                        202     $if  (EMULATOR <> 1)
                        203     Public Firmware_API_Run_State_Machine
                        204     $endif 
                        205     
                        206     ; Firmware jumptable
                        207     Public Firmware_EraseUCMBlock, _Firmware_EraseUCMBlock
                        208     Public Firmware_GetChipID, _Firmware_GetChipID
                        209     Public Firmware_SetProtectStatus, _Firmware_SetProtectStatus
                        210     Public Firmware_SetSecurityAction, _Firmware_SetSecurityAction
                        211     Public Firmware_SetSecurityMask, _Firmware_SetSecurityMask
                        212     Public Firmware_GetFirmwareVersion, _Firmware_GetFirmwareVersion
                        213     Public Firmware_SetClock, _Firmware_SetClock
                        214     Public Firmware_SetClockTrim, _Firmware_SetClockTrim
                        215     Public Firmware_GetClockSourceSelectSFR, _Firmware_GetClockSourceSelectSFR
                        216     Public Firmware_GetClockControlSFR, _Firmware_GetClockControlSFR
                        217     Public Firmware_SetExecuteOnlyStatus, _Firmware_SetExecuteOnlyStatus
                        218     Public Firmware_GetDiagnosticData, _Firmware_GetDiagnosticData
                        219     Public Firmware_GetRandomNumber, _Firmware_GetRandomNumber
                        220     Public Firmware_Set_IO_Pullup, _Firmware_Set_IO_Pullup
                        221     $if  (EMULATOR = 1)
                                Public Firmware_SetInterruptEnable, _Firmware_SetInterruptEnable
                                Public Firmware_GetInterruptEnable, _Firmware_GetInterruptEnable
                                $endif 
                        225     
                        226     
0001CE                  227     CSEG at 0x1CE
                        228     
0001CE                  229     _Firmware_SetClockTrim:
0001CE                  230     Firmware_SetClockTrim:                                  ds 2    ;1CE
                        231     
0001D0                  232     _Firmware_EraseUCMBlock:
0001D0                  233     Firmware_EraseUCMBlock:                                 ds 2    ;1D0
                        234     
0001D2                  235     _Firmware_SetSecurityAction:
0001D2                  236     Firmware_SetSecurityAction:                             ds 2    ;1D2
                        237     
0001D4                  238     _Firmware_SetSecurityMask:
0001D4                  239     Firmware_SetSecurityMask:                               ds 2    ;1D4
                        240     
0001D6                  241     _Firmware_SetExecuteOnlyStatus:
0001D6                  242     Firmware_SetExecuteOnlyStatus:                          ds 2    ;1D6
                        243     
0001D8                  244     _Firmware_SetProtectStatus:
0001D8                  245     Firmware_SetProtectStatus:                              ds 2    ;1D8
                        246     
0001DA                  247     _Firmware_GetChipID:
0001DA                  248     Firmware_GetChipID:                                     ds 2    ;1DA
                        249     
0001DC                  250     _Firmware_GetFirmwareVersion:
0001DC                  251     Firmware_GetFirmwareVersion:                            ds 2    ;1DC
                        252     
0001DE                  253     _Firmware_SetClock:
0001DE                  254     Firmware_SetClock:                                      ds 2    ;1DE
                        255     
0001E0                  256     _Firmware_GetClockSourceSelectSFR:
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     5

0001E0                  257     Firmware_GetClockSourceSelectSFR:                       ds 2    ;1E0
                        258     
0001E2                  259     _Firmware_GetClockControlSFR:
0001E2                  260     Firmware_GetClockControlSFR:                            ds 2    ;1E2
                        261     
0001E4                  262     _Firmware_GetDiagnosticData:
0001E4                  263     Firmware_GetDiagnosticData:                             ds 2    ;1E4
                        264     
0001E6                  265     _Firmware_GetRandomNumber:
0001E6                  266     Firmware_GetRandomNumber:                               ds 2    ;1E6
                        267     
0001F4                  268     CSEG at 0x1F4
                        269     
0001F4                  270     _Firmware_Set_IO_Pullup:
0001F4                  271     Firmware_Set_IO_Pullup:                                 ds 2    ;1F4
                        272     
                        273     $if  (EMULATOR = 1)
                                Firmware_API_WriteByteUCM:                              ds 2    ;1F6
                                Firmware_API_MassEraseUCM:                              ds 2    ;1F8
                                Firmware_API_ErasePageUCM:                              ds 2    ;1FA
                                
                                _Firmware_SetInterruptEnable:
                                Firmware_SetInterruptEnable:                            ds 2    ;1FC
                                
                                _Firmware_GetInterruptEnable:
                                Firmware_GetInterruptEnable:                            ds 2    ;1FE
                                $endif 
                        284     
                        285     
                        286     
                        287     $if  (EMULATOR = 1)
                                
                                ?DT?TT80_FSM_Interface_Segment?TT80_API_Jumptable SEGMENT DATA OVERLAYABLE
                                        RSEG     ?DT?TT80_FSM_Interface_Segment?TT80_API_Jumptable
                                
                                Temp_Addr_Hi:   ds 1                                    ; Temporary address storage
                                Temp_Addr_Lo:   ds 1
                                
                                $endif 
                        296     
                        297     
------                  298     ?PR?TT80_FSM_Interface_Segment?TT80_API_Jumptable SEGMENT CODE
------                  299             RSEG     ?PR?TT80_FSM_Interface_Segment?TT80_API_Jumptable
                        300     
                        301     
                        302     
                        303     
000000                  304     _Firmware_EraseUCM256Bytes:
000000                  305     Firmware_EraseUCM256Bytes:
000000                  306     _Firmware_ErasePageUCM:
000000                  307     Firmware_ErasePageUCM:
                        308     
000000 120000     F     309             lcall   Address_Boundary_Check                  ; Check address passed in r6 & r
                               7 is valid
000003 7075             310             jnz     Address_Error                           ; Address_Boundary_Check returns
                                0 if OK & FFh on error
                        311     
                        312     $if  (EMULATOR <> 1)
                        313     
                        314     ; Setup the DPTR with the destination address
000005 8E83             315             mov     dph,r6
000007 8F82             316             mov     dpl,r7
                        317     
                        318     ; Select the NVM operation you want to perform  
000009 75C910           319             mov     NvFsmMode,#10h                          ; XDATA space 256 Byte Erase sel
                               ected in FSM
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     6

                        320             
00000C 020000     F     321             ljmp    Firmware_API_Run_State_Machine          ; Run the State Machine, Setup R
                               etcode and RET
                        322     
                        323     $else  ; EMULATOR = 1
                                
                                        ljmp    Firmware_API_ErasePageUCM
                                
                                $endif 
                        328     
                        329     
00000F                  330     _Firmware_EraseUCM256Bytes_In_CODE_Space:
00000F                  331     Firmware_EraseUCM256Bytes_In_CODE_Space:
                        332     
                        333     $if  (EMULATOR <> 1)
                        334     
                        335     ; Setup the DPTR with the destination address
00000F 8E83             336             mov     dph,r6
000011 8F82             337             mov     dpl,r7
                        338     
                        339     ; Select the NVM operation you want to perform  
000013 75C911           340             mov     NvFsmMode,#11h                          ; CODE space 256 Byte Erase sele
                               cted in FSM
                        341             
000016 020000     F     342             ljmp    Firmware_API_Run_State_Machine          ; Run the State Machine, Setup R
                               etcode and RET
                        343     
                        344     $else  ; EMULATOR = 1
                                
                                        sjmp    Address_Error                           ; Firmware cannot modify CODE sp
                               ace
                                
                                $endif 
                        349     
                        350     
                        351     
                        352     
                        353     
                        354     
000019                  355     _Firmware_EraseUCM512Bytes:
000019                  356     Firmware_EraseUCM512Bytes:
                        357     
                        358     $if  (EMULATOR <> 1)
                        359     
000019 120000     F     360             lcall   Address_Boundary_Check                  ; Check address passed in r6 & r
                               7 is valid
00001C 705C             361             jnz     Address_Error                           ; Address_Boundary_Check returns
                                0 if OK & FFh on error
                        362     
                        363     ; Setup the DPTR with the destination address
00001E 8E83             364             mov     dph,r6
000020 8F82             365             mov     dpl,r7
                        366     
                        367     ; Select the NVM operation you want to perform  
000022 75C920           368             mov     NvFsmMode,#20h                          ; XDATA space 512 Byte Erase sel
                               ected in FSM
                        369             
000025 020000     F     370             ljmp    Firmware_API_Run_State_Machine          ; Run the State Machine, Setup R
                               etcode and RET
                        371     
                        372     $else  ; EMULATOR = 1
                                
                                        mov     Temp_Addr_Hi,r6                         ; Save page address
                                        mov     Temp_Addr_Lo,r7
                                        lcall   Firmware_API_ErasePageUCM               ; Erase first 256-byte page
                                
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     7

                                        mov     r6,Temp_Addr_Hi                         ; Restore page address and add 2
                               56
                                        inc     r6
                                        mov     r7,Temp_Addr_Lo
                                        ljmp    Firmware_API_ErasePageUCM               ; Erase second 256-byte page
                                
                                $endif 
                        384     
                        385     
                        386     
000028                  387     _Firmware_EraseUCM512Bytes_In_CODE_Space:
000028                  388     Firmware_EraseUCM512Bytes_In_CODE_Space:
                        389     
                        390     $if  (EMULATOR <> 1)
                        391     
000028 120000     F     392             lcall   Address_Boundary_Check                  ; Check address passed in r6 & r
                               7 is valid
00002B 704D             393             jnz     Address_Error                           ; Address_Boundary_Check returns
                                0 if OK & FFh on error
                        394     
                        395     ; Setup the DPTR with the destination address
00002D 8E83             396             mov     dph,r6
00002F 8F82             397             mov     dpl,r7
                        398     
                        399     ; Select the NVM operation you want to perform  
000031 75C921           400             mov     NvFsmMode,#21h                          ; CODE space 512 Byte Erase sele
                               cted in FSM
                        401             
000034 020000     F     402             ljmp    Firmware_API_Run_State_Machine          ; Run the State Machine, Setup R
                               etcode and RET
                        403     
                        404     $else  ; EMULATOR = 1
                                
                                        sjmp    Address_Error                           ; Firmware cannot modify CODE sp
                               ace
                                
                                $endif 
                        409     
                        410     
                        411     
                        412     
                        413     
                        414     
000037                  415     _Firmware_WriteByteUCM_In_CODE_Space:
000037                  416     Firmware_WriteByteUCM_In_CODE_Space:
                        417     
                        418     $if  (EMULATOR <> 1)
                        419     
000037 120000     F     420             lcall   Address_Boundary_Check                  ; Check address passed in r6 & r
                               7 is valid
00003A 703E             421             jnz     Address_Error                           ; Address_Boundary_Check returns
                                0 if OK & FFh on error
                        422     
                        423     ; Setup the DPTR with the destination address
00003C 8E83             424             mov     dph,r6
00003E 8F82             425             mov     dpl,r7
                        426     
                        427     ; Select the NVM operation you want to perform  
000040 75C905           428             mov     NvFsmMode,#05h                          ; CODE space Byte Write selected
                                in FSM
                        429             
                        430     ; For Byte Writes you must have the desired byte in Acc.
000043 ED               431             mov     a,r5
000044 020000     F     432             ljmp    Firmware_API_Run_State_Machine          ; Run the State Machine, Setup R
                               etcode and RET
                        433     
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     8

                        434     $else  ; EMULATOR = 1
                                
                                        sjmp    Address_Error                           ; Firmware cannot modify CODE sp
                               ace
                                
                                $endif 
                        439     
                        440     
                        441     
                        442     
000047                  443     _Firmware_WriteByteUCM:
000047                  444     Firmware_WriteByteUCM:
                        445     
000047 120000     F     446             lcall   Address_Boundary_Check                  ; Check address passed in r6 & r
                               7 is valid
00004A 702E             447             jnz     Address_Error                           ; Address_Boundary_Check returns
                                0 if OK & FFh on error
                        448     
                        449     $if  (EMULATOR <> 1)
                        450     
                        451     ; Setup the DPTR with the destination address
00004C 8E83             452             mov     dph,r6
00004E 8F82             453             mov     dpl,r7
                        454     
                        455     ; Select the NVM operation you want to perform  
000050 75C904           456             mov     NvFsmMode,#04h                          ; XDATA space Byte Write selecte
                               d in FSM
                        457             
                        458     ; For Byte Writes you must have the desired byte in Acc.
000053 ED               459             mov     a,r5
                        460     
                        461     $else  ; EMULATOR = 1
                                
                                        ljmp    Firmware_API_WriteByteUCM
                                
                                $endif 
                        466     
                        467     
                        468     
                        469     
                        470     
                        471     $if  (EMULATOR <> 1)
                        472     
                        473     ; Set the NVM Finite Statem Machine running
000054                  474     Firmware_API_Run_State_Machine:
                        475     
                        476     ; Setup the FSM with the desired address.
                        477     ; This line MUST be included as this sets up hardware in the FSM.
                        478     ; You MUST have the destination address in the DPTR at this point.
                        479     ; For Byte Writes you must have the desired byte in Acc.
                        480     ; For Page Erases the value of Acc doesn't matter.
000054 F0               481             movx    @dptr,a                                 ; Select memory address
                        482     
000055 438002           483             orl     NvFsmCon,#02h                           ; Set Start Bit
000058 3080FD           484             jnb     NvFsmCon.0,$                            ; Wait for the NvInt flag
                        485                                                             ; This tells us the FSM has comp
                               leted its task
00005B C280             486             clr     NvFsmCon.0                              ; Clear the NvInt flag
                        487     
                        488     ; Here we setup a return code for a C function
                        489     ; Success will be 1 if FSM operation successful
                        490     ; Will be 0 if FSM operation failed.
00005D 7F00             491             mov     r7,#0                                   ; Assume Success until we check 
                               below
00005F 208502           492             jb      NvFsmCon.5,Firmware_API_Run_State_Machine__Return
000062 7FFF             493             mov     r7,#0FFh                                ; If Success bit not set then re
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE     9

                               turn Fail
                        494     
000064                  495     Firmware_API_Run_State_Machine__Return:
                        496     
000064 22               497             ret
                        498     
                        499     $endif 
                        500     
                        501     
                        502     
                        503     
000065                  504     _Firmware_MassEraseUCM:
000065                  505     Firmware_MassEraseUCM:
                        506     
                        507     $if  (EMULATOR = 1)
                                
                                        ljmp    Firmware_API_MassEraseUCM
                                
                                $else  ; EMULATOR <> 1
                        512     
                        513     ; Do the Mass Erase via the FSM
                        514     
                        515     ; NOTE - this erases all UCM...including bootloader and OS. 
                        516     ; So there is nothing to execute on return of this function
000065 75C970           517             mov     NvFsmMode,#070h                         ; Mass Erase UCM
000068 758002           518             mov     NvFsmCon,#02h                           ; Set Start Bit
00006B 3080FD           519             jnb     NvFsmCon.0,$                            ; Wait for the Done flag
00006E 22               520             ret
                        521     
                        522     $endif 
                        523     
                        524     
                        525     
                        526     
00006F                  527     _Address_Boundary_Check:
00006F                  528     Address_Boundary_Check:
                        529     
                        530     ; R6 & R7 contain the address of page to erase
                        531     ; Check that the page is within the UCM boundary
                        532     ; for the TT80 UCM
                        533     ; e.g. Only addresses above 800h are allowed
00006F C3               534             clr     c
000070 EE               535             mov     a,r6
000071 9408             536             subb    a,#08h                                  ; check the high address byte is
                                above 08h
000073 4002             537             jc      Return_Error
000075 E4               538             clr     a                                       ; if the code gets here the addr
                               ess is within the 
                        539                                                             ; TT80 UCM boundary so return 0 
                               in Acc
000076 22               540             ret
                        541     
000077                  542     Return_Error:   
000077 74FF             543             mov     a,#0FFh                                 ; return FFh in Acc to state add
                               ress violation
                        544     
000079 22               545             ret                                             ; This should return to the call
                               ing NVM function
                        546     
                        547     
                        548     
00007A                  549     Address_Error:
00007A 7FFF             550             mov     r7,#0FFh                                ; code failed becuase of address
                                boundary check
                        551                                                             ; put FFh into r7 (NVM operation
                                failed) & return to calling function
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE    10

00007C 22               552             ret
                        553     
                        554     END
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE    11

SYMBOL TABLE LISTING
------ ----- -------


N A M E                                    T Y P E  V A L U E     ATTRIBUTES

?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMC  SEG   00007DH       REL=UNIT, ALN=BYTE
_ADDRESS_BOUNDARY_CHECK . . . . . . . .    C  ADDR  006FH     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEPAGEUCM. . . . . . . . .    C  ADDR  0000H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEUCM256BYTES. . . . . . .    C  ADDR  0000H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEUCM256BYTES_IN_CODE_SPACE   C  ADDR  000FH     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEUCM512BYTES. . . . . . .    C  ADDR  0019H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEUCM512BYTES_IN_CODE_SPACE   C  ADDR  0028H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_ERASEUCMBLOCK . . . . . . . .    C  ADDR  01D0H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETCHIPID . . . . . . . . . .    C  ADDR  01DAH     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETCLOCKCONTROLSFR. . . . . .    C  ADDR  01E2H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETCLOCKSOURCESELECTSFR . . .    C  ADDR  01E0H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETDIAGNOSTICDATA . . . . . .    C  ADDR  01E4H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETFIRMWAREVERSION. . . . . .    C  ADDR  01DCH     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_GETRANDOMNUMBER . . . . . . .    C  ADDR  01E6H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_MASSERASEUCM. . . . . . . . .    C  ADDR  0065H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_SET_IO_PULLUP . . . . . . . .    C  ADDR  01F4H     R   SEG=?CO?TT80_API_JUMPTABLE?2
_FIRMWARE_SETCLOCK. . . . . . . . . . .    C  ADDR  01DEH     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_SETCLOCKTRIM. . . . . . . . .    C  ADDR  01CEH     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_SETEXECUTEONLYSTATUS. . . . .    C  ADDR  01D6H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_SETPROTECTSTATUS. . . . . . .    C  ADDR  01D8H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_SETSECURITYACTION . . . . . .    C  ADDR  01D2H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_SETSECURITYMASK . . . . . . .    C  ADDR  01D4H     R   SEG=?CO?TT80_API_JUMPTABLE?1
_FIRMWARE_WRITEBYTEUCM. . . . . . . . .    C  ADDR  0047H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
_FIRMWARE_WRITEBYTEUCM_IN_CODE_SPACE. .    C  ADDR  0037H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
AC. . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.6   A   
ACC . . . . . . . . . . . . . . . . . .    D  ADDR  00E0H     A   
ADDRESS_BOUNDARY_CHECK. . . . . . . . .    C  ADDR  006FH     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
ADDRESS_ERROR . . . . . . . . . . . . .    C  ADDR  007AH     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
AM. . . . . . . . . . . . . . . . . . .    B  ADDR  00E8H.0   A   
B . . . . . . . . . . . . . . . . . . .    D  ADDR  00F0H     A   
CBSL. . . . . . . . . . . . . . . . . .    D  ADDR  00A1H     A   
CY. . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.7   A   
DPH . . . . . . . . . . . . . . . . . .    D  ADDR  0083H     A   
DPH0. . . . . . . . . . . . . . . . . .    D  ADDR  0083H     A   
DPH1. . . . . . . . . . . . . . . . . .    D  ADDR  0085H     A   
DPL . . . . . . . . . . . . . . . . . .    D  ADDR  0082H     A   
DPL0. . . . . . . . . . . . . . . . . .    D  ADDR  0082H     A   
DPL1. . . . . . . . . . . . . . . . . .    D  ADDR  0084H     A   
DPS . . . . . . . . . . . . . . . . . .    D  ADDR  0086H     A   
DPX . . . . . . . . . . . . . . . . . .    D  ADDR  0093H     A   
DPX0. . . . . . . . . . . . . . . . . .    D  ADDR  0093H     A   
DPX1. . . . . . . . . . . . . . . . . .    D  ADDR  0095H     A   
EPSW. . . . . . . . . . . . . . . . . .    D  ADDR  00E8H     A   
F0. . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.5   A   
F1. . . . . . . . . . . . . . . . . . .    B  ADDR  00E8H.1   A   
FIRMWARE_API_RUN_STATE_MACHINE. . . . .    C  ADDR  0054H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_API_RUN_STATE_MACHINE__RETURN.    C  ADDR  0064H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEPAGEUCM . . . . . . . . .    C  ADDR  0000H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEUCM256BYTES . . . . . . .    C  ADDR  0000H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEUCM256BYTES_IN_CODE_SPACE    C  ADDR  000FH     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEUCM512BYTES . . . . . . .    C  ADDR  0019H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEUCM512BYTES_IN_CODE_SPACE    C  ADDR  0028H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_ERASEUCMBLOCK. . . . . . . . .    C  ADDR  01D0H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETCHIPID. . . . . . . . . . .    C  ADDR  01DAH     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETCLOCKCONTROLSFR . . . . . .    C  ADDR  01E2H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETCLOCKSOURCESELECTSFR. . . .    C  ADDR  01E0H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETDIAGNOSTICDATA. . . . . . .    C  ADDR  01E4H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETFIRMWAREVERSION . . . . . .    C  ADDR  01DCH     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_GETRANDOMNUMBER. . . . . . . .    C  ADDR  01E6H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_MASSERASEUCM . . . . . . . . .    C  ADDR  0065H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
AX51 MACRO ASSEMBLER  TT80_API_JUMPTABLE                                                    04/16/07 10:40:54 PAGE    12

FIRMWARE_SET_IO_PULLUP. . . . . . . . .    C  ADDR  01F4H     R   SEG=?CO?TT80_API_JUMPTABLE?2
FIRMWARE_SETCLOCK . . . . . . . . . . .    C  ADDR  01DEH     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_SETCLOCKTRIM . . . . . . . . .    C  ADDR  01CEH     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_SETEXECUTEONLYSTATUS . . . . .    C  ADDR  01D6H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_SETPROTECTSTATUS . . . . . . .    C  ADDR  01D8H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_SETSECURITYACTION. . . . . . .    C  ADDR  01D2H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_SETSECURITYMASK. . . . . . . .    C  ADDR  01D4H     R   SEG=?CO?TT80_API_JUMPTABLE?1
FIRMWARE_WRITEBYTEUCM . . . . . . . . .    C  ADDR  0047H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FIRMWARE_WRITEBYTEUCM_IN_CODE_SPACE . .    C  ADDR  0037H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
FSM_FINISH. . . . . . . . . . . . . . .    B  ADDR  0080H.0   A   
FSM_RESULT. . . . . . . . . . . . . . .    B  ADDR  0080H.5   A   
FSM_START . . . . . . . . . . . . . . .    B  ADDR  0080H.1   A   
IE. . . . . . . . . . . . . . . . . . .    D  ADDR  00A8H     A   
IP. . . . . . . . . . . . . . . . . . .    D  ADDR  00B8H     A   
ISOCON. . . . . . . . . . . . . . . . .    D  ADDR  00B2H     A   
ISOTMR. . . . . . . . . . . . . . . . .    D  ADDR  00B4H     A   
MFCON . . . . . . . . . . . . . . . . .    D  ADDR  00F7H     A   
MFLT. . . . . . . . . . . . . . . . . .    B  ADDR  0088H.3   A   
MPTR. . . . . . . . . . . . . . . . . .    D  ADDR  00A2H     A   
MPTRX . . . . . . . . . . . . . . . . .    D  ADDR  00EAH     A   
NVFSMCON. . . . . . . . . . . . . . . .    D  ADDR  0080H     A   
NVFSMMODE . . . . . . . . . . . . . . .    D  ADDR  00C9H     A   
OV. . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.2   A   
P . . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.0   A   
PCON. . . . . . . . . . . . . . . . . .    D  ADDR  0087H     A   
PROGIO. . . . . . . . . . . . . . . . .    D  ADDR  00C0H     A   
PSW . . . . . . . . . . . . . . . . . .    D  ADDR  00D0H     A   
PULLUP_RES_STATE. . . . . . . . . . . .    B  ADDR  00C0H.0   A   
RETURN_ERROR. . . . . . . . . . . . . .    C  ADDR  0077H     R   SEG=?PR?TT80_FSM_INTERFACE_SEGMENT?TT80_API_JUMPTABLE
RI. . . . . . . . . . . . . . . . . . .    B  ADDR  0098H.0   A   
RS0 . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.3   A   
RS1 . . . . . . . . . . . . . . . . . .    B  ADDR  00D0H.4   A   
SBUF. . . . . . . . . . . . . . . . . .    D  ADDR  0099H     A   
SCON. . . . . . . . . . . . . . . . . .    D  ADDR  0098H     A   
SECURITYSTATUS. . . . . . . . . . . . .    D  ADDR  00B0H     A   
SINT. . . . . . . . . . . . . . . . . .    B  ADDR  0088H.1   A   
SP. . . . . . . . . . . . . . . . . . .    D  ADDR  0081H     A   
SPSW. . . . . . . . . . . . . . . . . .    D  ADDR  00D8H     A   
SSINT . . . . . . . . . . . . . . . . .    B  ADDR  0088H.0   A   
TCON. . . . . . . . . . . . . . . . . .    D  ADDR  0088H     A   
TF0 . . . . . . . . . . . . . . . . . .    B  ADDR  0088H.5   A   
TF1 . . . . . . . . . . . . . . . . . .    B  ADDR  0088H.7   A   
TH0 . . . . . . . . . . . . . . . . . .    D  ADDR  008CH     A   
TH1 . . . . . . . . . . . . . . . . . .    D  ADDR  008DH     A   
TI. . . . . . . . . . . . . . . . . . .    B  ADDR  0098H.1   A   
TL0 . . . . . . . . . . . . . . . . . .    D  ADDR  008AH     A   
TL1 . . . . . . . . . . . . . . . . . .    D  ADDR  008BH     A   
TMOD. . . . . . . . . . . . . . . . . .    D  ADDR  0089H     A   
TR0 . . . . . . . . . . . . . . . . . .    B  ADDR  0088H.4   A   
TR1 . . . . . . . . . . . . . . . . . .    B  ADDR  0088H.6   A   
USINT . . . . . . . . . . . . . . . . .    B  ADDR  0088H.1   A   


REGISTER BANK(S) USED: 0 


ASSEMBLY COMPLETE.  0 WARNING(S), 0 ERROR(S).
