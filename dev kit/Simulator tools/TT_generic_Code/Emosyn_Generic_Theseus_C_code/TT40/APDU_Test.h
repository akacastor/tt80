/******************************************************************************
*
* Name:         APDU_Test.h
* Description:  Header file containing Emosyn APDU commands for the TT40 chip
*               used for test script file Apdu_Test.ini 
* $Revision: 1.0 $
* $Author: Lisa $
* $Date: 2007/01/05 $
******************************************************************************/


/********************************************************************
* Below is the function pointer table for the APDU commands   
* note: The last data of every line is return data numbers from card  
*********************************************************************/
code APDU_Command_Buffer []= 
{
	0xE5, 0x0A, 0x00, 0x00, 0x08, 11,		//Get_Chip_ID -- return 9000
	0xE5, 0x0A, 0x00, 0x00, 0x09, 03,		//Get_Chip_ID -- return 6C00

	0xE5, 0x0C, 0x00, 0x00, 0x01, 04,		//Get_Clock_Source -- return 9000
	0xE5, 0x0C, 0x00, 0x00, 0x02, 03,		//Get_Clock_Source -- return 6C00

	0xE5, 0x0E, 0x00, 0x00, 0x01, 04,		//Get_Clock_Control -- return 9000
	0xE5, 0x0E, 0x00, 0x00, 0x02, 03,		//Get_Clock_Control -- return 6C00

	0xE5, 0x10, 0x00, 0x00, 0x02, 01,		//Set_Protection_Status -- return 9000
	  0xDC, 0x00, 02,
	0xE5, 0x10, 0x00, 0x00, 0x03, 03,		//Set_Protection_Status -- return 6700

	0xE5, 0x12, 0x00, 0x00, 0x02, 01,		//Set_Execute_Only_Status -- return 9000
	  0x00, 0xE0, 02,
	0xE5, 0x12, 0x00, 0x00, 0x03, 03,		//Set_Execute_Only_Status -- return 6700

	0xE5, 0x14, 0x40, 0x01, 0x00, 03,		//Set_Security_Action -- return 9000
	0xE5, 0x16, 0x20, 0x01, 0x00, 03,		//Set_Security_Mask -- return 9000

	0xE5, 0x18, 0x00, 0x00, 0x03, 01,		//Set_Clock -- return 9000
	  0x00, 0x00, 0x01, 02,
//	0xE5, 0x18, 0x00, 0x00, 0x03, 01,		//Set_Clock --lead to stop
//	  0x00, 0x00, 0x0F, 02,
	0xE5, 0x18, 0x00, 0x00, 0x03, 01,		//Set_Clock -- return 6A80
	  0xFE, 0xFE, 0xFE, 02,

//	0xE5, 0x1A, 0x82, 0x00, 0x00, 03,		//Set_Interrupt_Enable -- lead to stop
	0xE5, 0x1C, 0x00, 0x00, 0x01, 04,		//Get_Interrupt_enable -- return 9000
	0xE5, 0x1C, 0x00, 0x00, 0x02, 03,		//Get_Interrupt_enable -- return 6C00

	0xE5, 0x1E, 0x00, 0x00, 0x01, 04,		//Get_Firmware_Version -- return 9000
	0xE5, 0x1E, 0x00, 0x00, 0x02, 03,		//Get_Firmware_Version -- return 6C00

	0xE5, 0x20, 0x60, 0x00, 0x02, 01,		//Write_UCM_Bytes_Flash_Mode_From_IRAM_Buffer -- return 9000
	  0x40, 0x20, 02,
	0xE5, 0x20, 0x60, 0x00, 0x03, 03,		//Write_UCM_Bytes_Flash_Mode_From_IRAM_Buffer -- return 6700

	0xE5, 0x26, 0x12, 0x34, 0x01, 01,		//Write_Byte_UCM_Flash_Mode -- return 9000
	  0x55, 02,
	0xE5, 0x26, 0x12, 0x34, 0x02, 03,		//Write_Byte_UCM_Flash_Mode -- return 6700
	0xE5, 0x26, 0x00, 0x00, 0x01, 01,		//Write_Byte_UCM_Flash_Mode -- return 6581
	  0x55, 02,

	0xE5, 0x2C, 0x80, 0x00, 0x00, 03,		//Erase_256_UCM -- return 9000
	0xE5, 0x2C, 0xC0, 0x00, 0x00, 03,		//Erase_256_UCM -- return 6581

//	0xE5, 0x30, 0x00, 0x00, 0x00, 03,		//Erase all of the UCM except the bootloader -- lead to stop
//	0xE5, 0x32, 0x00, 0x00, 0x00, 03,		//Mass_Erase_UCM -- lead to stop

	0xE5, 0x3E, 0x70, 0x00, 0x00, 03,		//Erase_512_UCM -- return 9000

	0xE5, 0x40, 0x11, 0x00, 0x00, 03,		//Change_ISO_Speed -- return 9000
	0xE5, 0x40, 0x90, 0x00, 0x00, 03,		//Change_ISO_Speed -- return 6A86

	0xE5, 0x42, 0x33, 0x00, 0x00, 05,		//Set_Security_Status -- return 9000
	0xE5, 0x44, 0x00, 0x00, 0x01, 04,		//Get_Security_Status -- return 9000
	0xE5, 0x44, 0x00, 0x00, 0x02, 03,		//Get_Security_Status -- return 6C00

	0xE5, 0x4A, 0x00, 0x00, 0x01, 01,		//Timer0_Start -- return 9000
	  0x01, 0x02,
//	0xE5, 0x4A, 0x00, 0x00, 0x02, 03,		//Timer0_Start -- return 9000 ??better return 6700
	0xE5, 0x4E, 0x00, 0x00, 0x00, 03,		//Timer0_Stop -- return 9000

	0xE5, 0x52, 0x00, 0x28, 0x00, 03,		//Erase_UCM_Blocks__R6R7_Passing -- return 9000

	0xE5, 0x54, 0x00, 0x00, 0x08, 11,		//Get_Diagnostic_Data -- return 9000
	0xE5, 0x54, 0x00, 0x00, 0x09, 03,		//Get_Diagnostic_Data -- return 6C00

//	0xE5, 0x5A, 0x01, 0x00, 0x00, 03,		//Set_Idle_Mode --lead to stop
//	0xE5, 0x5A, 0x00, 0x00, 0x00, 03,		//Set_Idle_Mode --lead to stop

 	0xE5, 0x5C, 0x00, 0x00, 0x05, 8,		//Timer0_Read -- return 9000
 	0xE5, 0x5C, 0x00, 0x00, 0x06, 03,		//Timer0_Read -- return 6C00

	0xE5, 0x78, 0xFF, 0x80, 0x14, 23,		//Call_SHA1 -- return 9000
	0xE5, 0x78, 0xFF, 0x80, 0x10, 03,		//Call_SHA1 -- return 6C00

	0xE5, 0x7A, 0x12, 0x34, 0x06, 9,		//CODE_Memory_Dump -- return 9000
	0xE5, 0x7C, 0x12, 0x00, 0x06, 9,		//IDATA_Memory_Dump -- return 9000
	0xE5, 0x7E, 0x12, 0x34, 0x06, 9,		//XDATA_Memory_Dump -- return 9000

	0xE5, 0x88, 0x12, 0x34, 0x02, 05,		//Create_CRC16_Hash_Of_XDATA -- return 9000
	0xE5, 0x88, 0x12, 0x34, 0x03, 03,		//Create_CRC16_Hash_Of_XDATA -- return 6C00

	0xE5, 0x8C, 0x00, 0x40, 0x02, 01,		//Write_To_IRAM -- return 9000
	  0x11, 0x22, 02,

	0xE5, 0x8E, 0x00, 0x00, 0x02, 05,		//Get_OS_Version -- return 9000
	0xE5, 0x8E, 0x00, 0x00, 0x03, 05,		//Get_OS_Version -- return 9000 ??better return 6C00

	0xE5, 0xAA, 0x01, 0x00, 0x00, 03,		//Use_Emulator_API -- return 9000
	0xE5, 0xAA, 0x00, 0x00, 0x00, 03,		//Use_Emulator_API -- return 9000

	0xE5, 0xB4, 0x12, 0x34, 0x02, 01,		//Write_To_XRAM -- return 9000
	 0x11, 0x22, 02,

	0xE5, 0xC0, 0x00, 0x00, 0x08, 11,		//Get_Response -- return 9000
	0xE5, 0xC0, 0x00, 0x00, 0x09, 12,		//Get_Response -- return 9000 

	0xE5, 0xE0, 0x12, 0x34, 0x03, 01,		//Write_X_Bytes_To_UCM -- return 9000 
	  0x01, 0x02, 0x03, 02,  
	0xE5, 0xE4, 0xA0, 0x00, 0x01, 01,		//Write_X_Bytes_To_UCM__Page_Backup_Handled --- return 6581
	  0x11, 02,  

	0xE5, 0xE8, 0x00, 0x00, 0x01, 04,		//Get_Idle_Mode -- return 9000
	0xE5, 0xE8, 0x00, 0x00, 0x02, 03,		//Get_Idle_Mode -- return 6C00

	0xE5, 0xF0, 0x01, 0x01, 0x00, 03,		//Set_Pullup_Resistor -- return 9000	
	0xE5, 0xF2, 0x00, 0x00, 0x01, 04,		//Get_Pullup_Resistor -- return 9000
	0xE5, 0xF2, 0x00, 0x00, 0x02, 03,		//Get_Pullup_Resistor -- return 6C00

	0xFF						//end of the command						 
};


